// Copyright 2020 ConsenSys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by consensys/gnark-crypto DO NOT EDIT

package fft

import (
	"github.com/consensys/accelerated-crypto-monorepo/maths/common/matrix"
	"github.com/consensys/accelerated-crypto-monorepo/maths/common/vector"
	"github.com/consensys/accelerated-crypto-monorepo/maths/field"
	"reflect"
	"testing"

	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/prop"
)

func TestBatchFFT(t *testing.T) {
	const maxSize = 1 << 5

	domainWithPrecompute := NewDomain(maxSize)

	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 5

	properties := gopter.NewProperties(parameters)

	properties.Property("FFT and BatchFFT should be consistent (DIT)", prop.ForAll(

		// checks that a random evaluation of a dual function eval(gen**ithpower) is consistent with the FFT result
		func() *gopter.PropResult {

			vec := vector.Rand(maxSize)
			mat := matrix.Transpose([][]field.Element{vec})

			domainWithPrecompute.FFT(vec, DIT)
			domainWithPrecompute.BatchFFT(mat, DIT)

			vecPrime := matrix.Transpose(mat)[0]

			if !reflect.DeepEqual(vec, vecPrime) {
				t.Logf("vec %v, vecPrime %v", vector.Prettify(vec), vector.Prettify(vecPrime))
				return gopter.NewPropResult(false, "FFT and BatchFFT did not match")
			}

			return gopter.NewPropResult(true, "")
		},
	))

	properties.Property("FFT and BatchFFT should be consistent (DIF)", prop.ForAll(

		// checks that a random evaluation of a dual function eval(gen**ithpower) is consistent with the FFT result
		func() *gopter.PropResult {

			vec := vector.Rand(maxSize)
			mat := matrix.Transpose([][]field.Element{vec})

			domainWithPrecompute.FFT(vec, DIF)
			domainWithPrecompute.BatchFFT(mat, DIF)

			vecPrime := matrix.Transpose(mat)[0]

			if !reflect.DeepEqual(vec, vecPrime) {
				return gopter.NewPropResult(false, "FFT and BatchFFT did not match")
			}

			return gopter.NewPropResult(true, "")
		},
	))

	properties.Property("FFTInverse and BatchFFTInverse should be consistent (DIT)", prop.ForAll(

		// checks that a random evaluation of a dual function eval(gen**ithpower) is consistent with the FFTInverse result
		func() *gopter.PropResult {

			vec := vector.Rand(maxSize)
			mat := matrix.Transpose([][]field.Element{vec})

			domainWithPrecompute.FFTInverse(vec, DIT)
			domainWithPrecompute.BatchFFTInverse(mat, DIT)

			vecPrime := matrix.Transpose(mat)[0]

			if !reflect.DeepEqual(vec, vecPrime) {
				return gopter.NewPropResult(false, "FFTInverse and BatchFFTInverse did not match")
			}

			return gopter.NewPropResult(true, "")
		},
	))

	properties.Property("FFTInverse and BatchFFTInverse should be consistent (DIF)", prop.ForAll(

		// checks that a random evaluation of a dual function eval(gen**ithpower) is consistent with the FFTInverse result
		func() *gopter.PropResult {

			vec := vector.Rand(maxSize)
			mat := matrix.Transpose([][]field.Element{vec})

			domainWithPrecompute.FFTInverse(vec, DIF)
			domainWithPrecompute.BatchFFTInverse(mat, DIF)

			vecPrime := matrix.Transpose(mat)[0]

			if !reflect.DeepEqual(vec, vecPrime) {
				return gopter.NewPropResult(false, "FFTInverse and BatchFFTInverse did not match")
			}

			return gopter.NewPropResult(true, "")
		},
	))

	properties.TestingRun(t, gopter.ConsoleReporter(false))

}
