package cmd

import (
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"runtime/debug"
	"strings"
	"time"

	"github.com/consensys/accelerated-crypto-monorepo/backend/files"
)

// Manifest is the human readable manifest
// of the assets generated by the contract-gen command
type Manifest struct {
	Timestamp     time.Time `json:"timestamp"`
	Commit        string    `json:"commit"`
	GitStatus     string    `json:"git_status"`
	NbConstraints int       `json:"nb_constraints"`
	TrustedSRS    bool      `json:"trusted_srs"`
	CircuitName   string    `json:"circuit_name"`
	Files         []string  `json:"files"`
}

// NewManifest creates a new manifest
func NewManifest(nbConstraints int, circuitName string) *Manifest {
	gitStatus := ""
	if err := gitStatusCheck(); err != nil {
		printWarning("⚠️ warning ⚠️ " + err.Error())
		gitStatus = err.Error()
	}
	return &Manifest{
		Timestamp:     time.Now(),
		Commit:        commit,
		GitStatus:     gitStatus,
		NbConstraints: nbConstraints,
		TrustedSRS:    fTrustedSRS,
		CircuitName:   circuitName,
		Files: []string{
			circuitFile,
			pkFile,
			vkFile,
			solidityFile,
			manifestFile,
		},
	}
}

// Key derives a key from the manifest
// that can be used as a s3 bucket key
func (m *Manifest) Key() string {
	r := m.CircuitName
	if len(m.Commit) > 7 {
		r += "-" + m.Commit[:7]
	} else {
		r += "-" + m.Commit
	}
	r += "-" + m.Timestamp.Format("2006-01-02-15-04-05")
	if m.TrustedSRS {
		r += "-trusted"
	} else {
		r += "-untrusted"
	}
	if m.GitStatus != "" {
		r += "-dirtygit"
	}
	return strings.ToLower(r)
}

// Read reads a manifest from a json file
func (m *Manifest) Read(path string) error {
	f, err := os.Open(path)
	if err != nil {
		return err
	}
	defer f.Close()

	return json.NewDecoder(f).Decode(m)
}

// Write writes a manifest to a json file
func (m *Manifest) Write(path string) error {
	// convert to JSON
	b, err := json.MarshalIndent(m, "", "  ")
	if err != nil {
		return err
	}
	f := files.MustOverwrite(path)
	defer f.Close()

	_, err = f.Write(b)
	return err
}

var commit = func() string {
	if info, ok := debug.ReadBuildInfo(); ok {
		for _, setting := range info.Settings {
			if setting.Key == "vcs.revision" {
				return setting.Value
			}
		}
	}

	return ""
}()

// gitStatusCheck checks if all files are committed.
// returns an error if git status is not clean
func gitStatusCheck() error {
	out, err := exec.Command("git", "status", "--porcelain").Output()
	if err != nil {
		return err
	}
	sOut := string(out)
	if sOut != "" {
		return fmt.Errorf("git status is not clean: %s", sOut)
	}
	return nil
}
