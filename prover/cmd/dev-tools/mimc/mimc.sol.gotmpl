// SPDX-License-Identifier: Apache-2.0

// Copyright 2023 Consensys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by gnark DO NOT EDIT
pragma solidity 0.8.19;

library Mimc {
  uint256 constant FR_FIELD = 8444461749428370424248824938781546531375899335154063827935233455917409239041;
  
  function hash(bytes calldata _msg) external pure returns (bytes32 mimcHash) {
    assembly {
      let chunks := div(add(_msg.length, 0x1f), 0x20)

      for {
        let i := 0
      } lt(i, sub(chunks, 1)) {
        i := add(i, 1)
      } {
        let offset := add(_msg.offset, mul(i, 0x20))
        let chunk := calldataload(offset)

        let r := encrypt(mimcHash, chunk)
        mimcHash := addmod(addmod(mimcHash, r, FR_FIELD), chunk, FR_FIELD)
      }

      let offset := add(_msg.offset, mul(sub(chunks, 1), 0x20))
      let lastChunk := calldataload(offset)

      if iszero(eq(mod(_msg.length, 0x20), 0)) {
        let remaining := mod(_msg.length, 0x20)
        lastChunk := shr(mul(sub(0x20, remaining), 0x8), lastChunk)
      }

      let r := encrypt(mimcHash, lastChunk)
      mimcHash := addmod(addmod(mimcHash, r, FR_FIELD), lastChunk, FR_FIELD)

      function encrypt(h, chunk) -> output {
        let frField := FR_FIELD
        let tmpSum := 0

        tmpSum := addmod(
          addmod(chunk, h, frField),
          {{ index . 0 }},
          frField
        )
        output := mulmod(tmpSum, tmpSum, frField)
        output := mulmod(output, output, frField)
        output := mulmod(output, output, frField)
        output := mulmod(mulmod(output, output, frField), tmpSum, frField)
{{ range slice . 1 (sub (len .) 1) }}
        tmpSum := addmod(
          addmod(output, h, frField),
          {{ . }},
          frField
        )
        output := mulmod(tmpSum, tmpSum, frField)
        output := mulmod(output, output, frField)
        output := mulmod(output, output, frField)
        output := mulmod(mulmod(output, output, frField), tmpSum, frField)
{{ end }}
        tmpSum := addmod(
          addmod(output, h, frField),
          {{ index . (sub (len .) 1) }},
          frField
        )
        output := mulmod(tmpSum, tmpSum, frField)
        output := mulmod(output, output, frField)
        output := mulmod(output, output, frField)
        output := mulmod(mulmod(output, output, frField), tmpSum, frField)

        output := addmod(output, h, frField)
      }
    }
  }
}
